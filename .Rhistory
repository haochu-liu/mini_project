edge_index <- 1L
node_index <- as.integer(n + 1)
pool <- as.integer(1:n)
# clonal tree by coalescent only
while (k > 1) {
# sample a new event time
event_time <- rexp(1, rate=k*(k-1)/2)
t_sum <- t_sum + event_time
# coalescent event
leaf_node <- sample(pool, size=2, replace=FALSE)
# append edges
clonal_edge[c(edge_index, edge_index+1), 1] <- node_index
clonal_edge[c(edge_index, edge_index+1), 2] <- leaf_node
clonal_edge[c(edge_index, edge_index+1), 3] <- t_sum-clonal_node_height[leaf_node]
# append root node
clonal_node_height[node_index] <- t_sum
# updates for iteration
pool <- c(setdiff(pool, leaf_node), node_index)
edge_index <- edge_index + 2L
node_index <- node_index + 1L
k <- k - 1
}
# number of recombination edges
tree_length <- sum(clonal_edge[, 3])
# num of recombs | tree_length ~ Poisson(rho*l/2)
n_recomb <- rpois(1, rho*tree_length/2)
n_recomb
# Initialize recombination edges
recomb_edge <- matrix(NA, nrow=n_recomb, ncol=6) # matrix for b, a, x, y
colnames(recomb_edge) <- c("b_edge", "b_height",
"a_edge", "a_height",
"x", "y")
probstartcum <- cumsum(rep(1/L, L))
a_rexp <- rexp(n_recomb, rate=1)
a_rexp
# simulate b_edge (similar to mutation)
recomb_edge[, 1] <- sample(1:(2*(n-1)), n_recomb,
replace=TRUE, prob=clonal_edge[, 3])
# simulate x and y
recomb_edge[, 5] <- findInterval(runif(n_recomb), probstartcum) + 1
recomb_edge[, 6] <- pmin(recomb_edge[, 5] + rgeom(n_recomb, 1/delta), L)
for (i in 1:n_recomb) {
# simulate b_height
recomb_edge[i, 2] <- runif(1, max=clonal_edge[recomb_edge[i, 1], 3]) +
clonal_node_height[clonal_edge[recomb_edge[i, 1], 2]]
# identify a_height
t_above_b <- clonal_node_height[n:(2*n-1)] - recomb_edge[i, 2]
i_above_b <- c(0, t_above_b[t_above_b >= 0])
i_above_b <- i_above_b[2:length(i_above_b)] - i_above_b[1:(length(i_above_b)-1)]
cuml_above_b <- cumsum(i_above_b * (1+length(i_above_b)):2)
num_lineage <- (1+length(i_above_b)) - length(which(a_rexp[i] > cuml_above_b))
if (num_lineage == (1+length(i_above_b))) {
recomb_edge[i, 4] <- a_rexp[i] + recomb_edge[i, 2]
} else {
#recomb_edge[i, 4] <- (a_rexp[i]-cuml_above_b[1+length(i_above_b)-num_lineage]) / num_lineage +
#sum(i_above_b[1:(1+length(i_above_b)-num_lineage)]) +
#recomb_edge[i, 2]
recomb_edge[i, 4] <- (a_rexp[i]-cuml_above_b[1+length(i_above_b)-num_lineage]) +
sum(i_above_b[1:(1+length(i_above_b)-num_lineage)]) +
recomb_edge[i, 2]
}
# simulate a_edge
if (num_lineage > 1) {
# print(which(recomb_edge[i, 4] < clonal_node_height)[1] == (2*n+1-num_lineage))
pool_edge <- which((clonal_edge[, 1] >= (2*n+1-num_lineage)) &
(clonal_edge[, 2] < (2*n+1-num_lineage)))
recomb_edge[i, 3] <- sample(pool_edge, 1, replace=TRUE)
} else {
recomb_edge[i, 3] <- -1
}
}
# delete rows when having same in and out nodes
same_in_out <- which(recomb_edge[, 1] == recomb_edge[, 3])
if (length(same_in_out)) {
recomb_edge <- recomb_edge[-same_in_out, ]
n_recomb <- nrow(recomb_edge)
}
n_recomb
recomb_edge
clonal_edge
clonal_node_height
1.7576687 - 1.34732181 + (1.34732181 - 0.84706696) * 2
a_rexp
a_rexp[-same_in_out]
2.7825308 - 1.34732181 + (1.34732181 - 0.51276395) * 2 + (0.51276395 - 0.39363393) * 3 + (0.39363393 - 0.04672111) * 4 + (0.04672111 - 0.04218666) * 5
L
delta
rgeom(n_recomb, 1/delta)
rgeom(n_recomb, 1/delta)
rgeom(n_recomb, 1/delta)
rgeom(n_recomb, 1/delta)
rgeom(n_recomb, 1/delta)
rgeom(n_recomb, 1/delta)
rgeom(n_recomb, 1/delta)
rgeom(n_recomb, 1/delta)
rgeom(n_recomb, 1/delta)
rgeom(n_recomb, 1/delta)
rgeom(n_recomb, 1/delta)
rgeom(n_recomb, 1/2)
#' Input: number of leaf lineages, recombination parameter, number of sites,
#' delta is mean of the length of recombinant segment,
#' initial maximal node size (default = 1000),
#' optimise recombination edges or not
#' Create a full ARG using ClonalOrigin
#' Edge dataframe: root node, leaf node, edge length, edge material interval
#' Node dataframe: node index, node height, node material interval
#' Output: edge dataframe, node dataframe, waiting time for each event,
#' total time, number of lineages at each event time, number of leaf alleles,
#' recombination parameter, and parameter delta
sim_ClonalOrigin_ARG <- function(n, rho, L, delta, node_max=1000,
optimise_recomb=FALSE, edgemat=TRUE) {
if (n!=as.integer(n)) {
stop("Sample size must be an integer")
} else if (L!=as.integer(L)) {
stop("Number of sites must be an integer")
} else if (n >= node_max) {
stop("Maximal node size must greater than the number of leaf lineages")
}
k = n
k_vector <- c(k)
t <- vector("numeric", length = 0) # vector of event times
t_sum <- 0
edge_matrix <- matrix(NA, nrow=node_max, ncol=3) # root and leaf nodes, length
colnames(edge_matrix) <- c("node1", "node2", "length")
edge_mat_index <- rep(NA, node_max)              # edge material index
node_height <- rep(NA, node_max)                 # node height to recent time
node_mat <- matrix(NA, nrow=node_max, ncol=L)    # node material
node_clonal <- rep(NA, node_max)                 # node clonal
node_height[1:n] <- 0                            # initialize first n nodes
node_mat[1:n, ] <- 1
node_clonal[1:n] <- TRUE
# Probability of starting recombination at each site
probstart <- rep(1/L, L)
probstartcum <- cumsum(probstart)
# Initialize variables and vector
edge_index <- 1L
node_index <- as.integer(n + 1)
pool <- as.integer(1:n)
while (k > 1) {
# sample a new event time
event_time <- rexp(1, rate=k*(k-1+rho)/2)
t <- c(t, event_time)
t_sum <- t_sum + event_time
# sample whether the event is a coalescent
p_coale <- rbinom(n=1, size=1, prob=(k-1)/(k-1+rho))
if (p_coale == 1) {
# coalescent event
leaf_node <- sample(pool, size=2, replace=FALSE)
while (!any(node_clonal[leaf_node])) {
leaf_node <- sample(pool, size=2, replace=FALSE)
}
# append edges
edge_matrix[c(edge_index, edge_index+1), 1] <- node_index
edge_matrix[c(edge_index, edge_index+1), 2] <- leaf_node
edge_matrix[c(edge_index, edge_index+1), 3] <- t_sum-node_height[leaf_node]
edge_mat_index[c(edge_index, edge_index+1)] <- leaf_node
# append root node
node_height[node_index] <- t_sum
node_mat[node_index, ] <- as.integer(node_mat[leaf_node[1], ] |
node_mat[leaf_node[2], ])
# update clonal lineage
node_clonal[node_index] <- TRUE
# updates for iteration
pool <- c(setdiff(pool, leaf_node), node_index)
edge_index <- edge_index + 2L
node_index <- node_index + 1L
k <- k - 1
} else {
# recombination event
leaf_node <- sample(pool[node_clonal[pool]], size=1, replace=FALSE)
x <- which(runif(1) < probstartcum)[1]
y <- min(x + rgeom(1, 1/delta), L)
if (optimise_recomb & (sum(node_mat[leaf_node, x:y])==0)) {next}
edge_mat_index[c(edge_index, edge_index+1)] <- c(node_index, node_index+1)
node_mat[c(node_index, node_index+1), ] <- 0
node_mat[node_index, x:y] <- node_mat[leaf_node, x:y]
node_mat[node_index+1, -(x:y)] <- node_mat[leaf_node, -(x:y)]
# append edges
edge_matrix[c(edge_index, edge_index+1), 1] <- c(node_index, node_index+1L)
edge_matrix[c(edge_index, edge_index+1), 2] <- leaf_node
edge_matrix[c(edge_index, edge_index+1), 3] <- t_sum-node_height[leaf_node]
# append root node
node_height[c(node_index, node_index+1)] <- t_sum
# update clonal lineage
node_clonal[node_index] <- FALSE
node_clonal[node_index+1] <- TRUE
# updates for iteration
pool <- c(setdiff(pool, leaf_node), node_index, node_index+1L)
edge_index <- edge_index + 2L
node_index <- node_index + 2L
k <- k + 1
}
k_vector <- c(k_vector, k)
if (max(edge_index, node_index) >= node_max - 1) {
# add empty rows or elements if more edges than expected
edge_matrix <- rbind(edge_matrix, matrix(NA, nrow=node_max, ncol=3))
edge_mat_index <- c(edge_mat_index, rep(NA, node_max))
node_height <- c(node_height, rep(NA, node_max))
node_mat <- rbind(node_mat, matrix(NA, nrow=node_max, ncol=L))
node_clonal <- c(node_clonal, rep(NA, node_max))
node_max <- 2 * node_max
}
}
if (edgemat) {
ARG = list(edge=edge_matrix[1:(edge_index-1), ],
edge_mat=node_mat[edge_mat_index[1:(edge_index-1)], ],
node_height=node_height[1:(node_index-1)],
node_mat=node_mat[1:(node_index-1), ],
node_clonal=node_clonal[1:(node_index-1)],
waiting_time=t, sum_time=t_sum, k=k_vector, n=n, rho=rho, L=L,
delta=delta)
} else {
ARG = list(edge=edge_matrix[1:(edge_index-1), ],
node_height=node_height[1:(node_index-1)],
node_mat=node_mat[1:(node_index-1), ],
node_clonal=node_clonal[1:(node_index-1)],
waiting_time=t, sum_time=t_sum, k=k_vector, n=n, rho=rho, L=L,
delta=delta)
}
class(ARG) <- "sim_FSM_ARG"
return(ARG)
}
#| echo: true
height_t_df <- data.frame(s1=rep(NA, 2000),
s50=rep(NA, 2000),
s80=rep(NA, 2000),
type=c(rep("ARG-based", 1000), rep("Tree-based", 1000)))
for (i in 1:1000) {
ARG <- sim_ClonalOrigin_ARG(100L, 5, 100L, 5, optimise_recomb=TRUE)
Clonaltree <- simARG::ClonalOrigin(100L, 5, 100L, 5)
tree1 <- simARG::local_tree(ARG, 1L)
tree50 <- simARG::local_tree(ARG, 50L)
tree80 <- simARG::local_tree(ARG, 80L)
height_t_df$s1[i] <- tree1$sum_time
height_t_df$s50[i] <- tree50$sum_time
height_t_df$s80[i] <- tree80$sum_time
height_t_df$s1[i+1000] <- simARG::local_height_ClonalOrigin(Clonaltree, 1)
height_t_df$s50[i+1000] <- simARG::local_height_ClonalOrigin(Clonaltree, 50)
height_t_df$s80[i+1000] <- simARG::local_height_ClonalOrigin(Clonaltree, 80)
if (i%%100 == 0) {print(paste("Complete", i, "iterations"))}
}
#' Input: number of leaf lineages, recombination parameter, number of sites,
#' delta is mean of the length of recombinant segment,
#' initial maximal node size (default = 1000),
#' optimise recombination edges or not
#' Create a full ARG using ClonalOrigin
#' Edge dataframe: root node, leaf node, edge length, edge material interval
#' Node dataframe: node index, node height, node material interval
#' Output: edge dataframe, node dataframe, waiting time for each event,
#' total time, number of lineages at each event time, number of leaf alleles,
#' recombination parameter, and parameter delta
sim_ClonalOrigin_ARG <- function(n, rho, L, delta, node_max=1000,
optimise_recomb=FALSE, edgemat=TRUE) {
if (n!=as.integer(n)) {
stop("Sample size must be an integer")
} else if (L!=as.integer(L)) {
stop("Number of sites must be an integer")
} else if (n >= node_max) {
stop("Maximal node size must greater than the number of leaf lineages")
}
k = n
k_vector <- c(k)
t <- vector("numeric", length = 0) # vector of event times
t_sum <- 0
edge_matrix <- matrix(NA, nrow=node_max, ncol=3) # root and leaf nodes, length
colnames(edge_matrix) <- c("node1", "node2", "length")
edge_mat_index <- rep(NA, node_max)              # edge material index
node_height <- rep(NA, node_max)                 # node height to recent time
node_mat <- matrix(NA, nrow=node_max, ncol=L)    # node material
node_clonal <- rep(NA, node_max)                 # node clonal
node_height[1:n] <- 0                            # initialize first n nodes
node_mat[1:n, ] <- 1
node_clonal[1:n] <- TRUE
# Probability of starting recombination at each site
probstart <- rep(1/L, L)
probstartcum <- cumsum(probstart)
# Initialize variables and vector
edge_index <- 1L
node_index <- as.integer(n + 1)
pool <- as.integer(1:n)
while (k > 1) {
# sample a new event time
event_time <- rexp(1, rate=k*(k-1+rho)/2)
t <- c(t, event_time)
t_sum <- t_sum + event_time
# sample whether the event is a coalescent
p_coale <- rbinom(n=1, size=1, prob=(k-1)/(k-1+rho))
if (p_coale == 1) {
# coalescent event
leaf_node <- sample(pool, size=2, replace=FALSE)
while (!any(node_clonal[leaf_node])) {
leaf_node <- sample(pool, size=2, replace=FALSE)
}
# append edges
edge_matrix[c(edge_index, edge_index+1), 1] <- node_index
edge_matrix[c(edge_index, edge_index+1), 2] <- leaf_node
edge_matrix[c(edge_index, edge_index+1), 3] <- t_sum-node_height[leaf_node]
edge_mat_index[c(edge_index, edge_index+1)] <- leaf_node
# append root node
node_height[node_index] <- t_sum
node_mat[node_index, ] <- as.integer(node_mat[leaf_node[1], ] |
node_mat[leaf_node[2], ])
# update clonal lineage
node_clonal[node_index] <- TRUE
# updates for iteration
pool <- c(setdiff(pool, leaf_node), node_index)
edge_index <- edge_index + 2L
node_index <- node_index + 1L
k <- k - 1
} else {
# recombination event
leaf_node <- sample(pool[node_clonal[pool]], size=1, replace=FALSE)
x <- which(runif(1) < probstartcum)[1]
y <- min(x + rgeom(1, 1/delta), L)
if (optimise_recomb & (sum(node_mat[leaf_node, x:y])==0)) {next}
edge_mat_index[c(edge_index, edge_index+1)] <- c(node_index, node_index+1)
node_mat[c(node_index, node_index+1), ] <- 0
node_mat[node_index, x:y] <- node_mat[leaf_node, x:y]
node_mat[node_index+1, -(x:y)] <- node_mat[leaf_node, -(x:y)]
# append edges
edge_matrix[c(edge_index, edge_index+1), 1] <- c(node_index, node_index+1L)
edge_matrix[c(edge_index, edge_index+1), 2] <- leaf_node
edge_matrix[c(edge_index, edge_index+1), 3] <- t_sum-node_height[leaf_node]
# append root node
node_height[c(node_index, node_index+1)] <- t_sum
# update clonal lineage
node_clonal[node_index] <- FALSE
node_clonal[node_index+1] <- TRUE
# updates for iteration
pool <- c(setdiff(pool, leaf_node), node_index, node_index+1L)
edge_index <- edge_index + 2L
node_index <- node_index + 2L
k <- k + 1
}
k_vector <- c(k_vector, k)
if (max(edge_index, node_index) >= node_max - 1) {
# add empty rows or elements if more edges than expected
edge_matrix <- rbind(edge_matrix, matrix(NA, nrow=node_max, ncol=3))
edge_mat_index <- c(edge_mat_index, rep(NA, node_max))
node_height <- c(node_height, rep(NA, node_max))
node_mat <- rbind(node_mat, matrix(NA, nrow=node_max, ncol=L))
node_clonal <- c(node_clonal, rep(NA, node_max))
node_max <- 2 * node_max
}
}
if (edgemat) {
ARG = list(edge=edge_matrix[1:(edge_index-1), ],
edge_mat=node_mat[edge_mat_index[1:(edge_index-1)], ],
node_height=node_height[1:(node_index-1)],
node_mat=node_mat[1:(node_index-1), ],
node_clonal=node_clonal[1:(node_index-1)],
waiting_time=t, sum_time=t_sum, k=k_vector, n=n, rho=rho, L=L,
delta=delta)
} else {
ARG = list(edge=edge_matrix[1:(edge_index-1), ],
node_height=node_height[1:(node_index-1)],
node_mat=node_mat[1:(node_index-1), ],
node_clonal=node_clonal[1:(node_index-1)],
waiting_time=t, sum_time=t_sum, k=k_vector, n=n, rho=rho, L=L,
delta=delta)
}
class(ARG) <- "FSM_ARG"
return(ARG)
}
#| echo: true
height_t_df <- data.frame(s1=rep(NA, 2000),
s50=rep(NA, 2000),
s80=rep(NA, 2000),
type=c(rep("ARG-based", 1000), rep("Tree-based", 1000)))
for (i in 1:1000) {
ARG <- sim_ClonalOrigin_ARG(100L, 5, 100L, 5, optimise_recomb=TRUE)
Clonaltree <- simARG::ClonalOrigin(100L, 5, 100L, 5)
tree1 <- simARG::local_tree(ARG, 1L)
tree50 <- simARG::local_tree(ARG, 50L)
tree80 <- simARG::local_tree(ARG, 80L)
height_t_df$s1[i] <- tree1$sum_time
height_t_df$s50[i] <- tree50$sum_time
height_t_df$s80[i] <- tree80$sum_time
height_t_df$s1[i+1000] <- simARG::local_height_ClonalOrigin(Clonaltree, 1)
height_t_df$s50[i+1000] <- simARG::local_height_ClonalOrigin(Clonaltree, 50)
height_t_df$s80[i+1000] <- simARG::local_height_ClonalOrigin(Clonaltree, 80)
if (i%%100 == 0) {print(paste("Complete", i, "iterations"))}
}
#| echo: true
n <- 100
height_rate <- n:2 * (n-1):1 / 2
height_density <- function(x) {
dhypoexp(x, rate=height_rate)
}
hist1 <- ggplot(height_t_df, aes(x = s1, fill = type)) +
geom_histogram(aes(y = after_stat(density)),
bins = 30,
color = "black",
alpha = 0.3,
position = "identity") +
stat_function(fun = height_density, # Use your custom function here
color = "darkblue",
linewidth = 1.2,
linetype = "solid") +
labs(title = "Locat tree at site 1",
x = "Height",
y = "Density") +
theme_minimal()
hist2 <- ggplot(height_t_df, aes(x = s50, fill = type)) +
geom_histogram(aes(y = after_stat(density)),
bins = 30,
color = "black",
alpha = 0.3,
position = "identity") +
stat_function(fun = height_density, # Use your custom function here
color = "darkblue",
linewidth = 1.2,
linetype = "solid") +
labs(title = "Locat tree at site 50",
x = "Height",
y = "Density") +
theme_minimal()
hist3 <- ggplot(height_t_df, aes(x = s80, fill = type)) +
geom_histogram(aes(y = after_stat(density)),
bins = 30,
color = "black",
alpha = 0.3,
position = "identity") +
stat_function(fun = height_density, # Use your custom function here
color = "darkblue",
linewidth = 1.2,
linetype = "solid") +
labs(title = "Locat tree at site 80",
x = "Height",
y = "Density") +
theme_minimal()
combined_hist <- hist1 + hist2 + hist3
combined_hist <- combined_hist +
plot_annotation(
title = "simARG::ClonalOrigin_ARG(100L, 5, 100L, 5)")
print(combined_hist)
library(ggplot2)
library(devtools)
library(devtools)
library(sdprisk)
install("C:/Users/u2008181/simARG")
set.seed(10)
#| echo: true
height_t_df <- data.frame(s1=rep(NA, 2000),
s50=rep(NA, 2000),
s80=rep(NA, 2000),
type=c(rep("ARG-based", 1000), rep("Tree-based", 1000)))
for (i in 1:1000) {
ARG <- simARG::ClonalOrigin_ARG(100L, 5, 100L, 5, optimise_recomb=TRUE)
Clonaltree <- simARG::ClonalOrigin(100L, 5, 100L, 5)
tree1 <- simARG::local_tree(ARG, 1L)
tree50 <- simARG::local_tree(ARG, 50L)
tree80 <- simARG::local_tree(ARG, 80L)
height_t_df$s1[i] <- tree1$sum_time
height_t_df$s50[i] <- tree50$sum_time
height_t_df$s80[i] <- tree80$sum_time
height_t_df$s1[i+1000] <- simARG::local_height_ClonalOrigin(Clonaltree, 1)
height_t_df$s50[i+1000] <- simARG::local_height_ClonalOrigin(Clonaltree, 50)
height_t_df$s80[i+1000] <- simARG::local_height_ClonalOrigin(Clonaltree, 80)
if (i%%100 == 0) {print(paste("Complete", i, "iterations"))}
}
#| echo: true
n <- 100
height_rate <- n:2 * (n-1):1 / 2
height_density <- function(x) {
dhypoexp(x, rate=height_rate)
}
hist1 <- ggplot(height_t_df, aes(x = s1, fill = type)) +
geom_histogram(aes(y = after_stat(density)),
bins = 30,
color = "black",
alpha = 0.3,
position = "identity") +
stat_function(fun = height_density, # Use your custom function here
color = "darkblue",
linewidth = 1.2,
linetype = "solid") +
labs(title = "Locat tree at site 1",
x = "Height",
y = "Density") +
theme_minimal()
hist2 <- ggplot(height_t_df, aes(x = s50, fill = type)) +
geom_histogram(aes(y = after_stat(density)),
bins = 30,
color = "black",
alpha = 0.3,
position = "identity") +
stat_function(fun = height_density, # Use your custom function here
color = "darkblue",
linewidth = 1.2,
linetype = "solid") +
labs(title = "Locat tree at site 50",
x = "Height",
y = "Density") +
theme_minimal()
hist3 <- ggplot(height_t_df, aes(x = s80, fill = type)) +
geom_histogram(aes(y = after_stat(density)),
bins = 30,
color = "black",
alpha = 0.3,
position = "identity") +
stat_function(fun = height_density, # Use your custom function here
color = "darkblue",
linewidth = 1.2,
linetype = "solid") +
labs(title = "Locat tree at site 80",
x = "Height",
y = "Density") +
theme_minimal()
combined_hist <- hist1 + hist2 + hist3
hist1
hist2
