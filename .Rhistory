toCoalAncMat[, k + 1] <- toCoalAncMatSet
ancmat[1:L, nodes - 1] <- toCoalAncMat[, i]
ancmat[1:L, nodes] <- toCoalAncMatSet
ancmat[L + 1, nodes - 1] <- ancmat[L + 1, toCoal[i]]
toCoal[i] <- nodes - 1
toCoal[k + 1] <- nodes
k <- k + 1
}
}
# Finalize
s <- s[1:nodes, , drop = FALSE]
ages <- ages[1:nodes]
ancmat <- ancmat[, 1:nodes, drop = FALSE]
return(list(s = s, n=n, ages = ages, ancmat=ancmat, blocks=blocks, eq = eq))
}
library(profvis)
profvis(sim_FSM_ARG2(100, 5, 100, bacteria = TRUE, delta = 10,
node_max = 100000, optimise_recomb = TRUE))
profvis(simu(n=100, rho = 5, delta = 1, blocks = c(100), optimise = T))
profvis({sim_FSM_ARG2(100, 5, 100, bacteria = TRUE, delta = 10,
node_max = 100000, optimise_recomb = TRUE)})
profvis({simu(n=100, rho = 5, delta = 1, blocks = c(100), optimise = T)})
profvis(simu(n=100, rho = 5, delta = 1, blocks = c(100), optimise = T))
profvis(simu())
profvis({
n = 100
rho = 5
L = 100
bacteria = TRUE
delta = 10
node_max = 100000
optimise_recomb = TRUE
if (n!=as.integer(n)) {
stop("Sample size must be an integer")
} else if (L!=as.integer(L)) {
stop("Number of sites must be an integer")
} else if (bacteria & is.null(delta)) {
stop("Must provide parameter for the length of recombinant segment")
} else if (n >= node_max) {
stop("Maximal node size must greater than the number of leaf lineages")
}
k = n
k_vector <- c(k)
t <- vector("numeric", length = 0) # vector of event times
t_sum <- 0
edge_matrix <- matrix(NA, nrow=node_max, ncol=3) # root and leaf nodes, length
colnames(edge_matrix) <- c("node1", "node2", "length")
edge_mat <- matrix(NA, nrow=node_max, ncol=L)    # edge material
node_height <- rep(NA, node_max)                 # node height to recent time
node_mat <- matrix(NA, nrow=node_max, ncol=L)    # node material
node_height[1:n] <- 0                            # initialize first n nodes
node_mat[1:n, ] <- 1
# Probability of starting recombination at each site
probstart <- rep(1, L)
if (bacteria) {probstart[1] <- delta}
probstart <- probstart / sum(probstart)
probstartcum <- cumsum(probstart)
# Initialize variables and vector
edge_index <- 1
node_index <- n + 1
pool <- as.integer(1:n)
next_node <- as.integer(n+1)
while (k > 1) {
# sample a new event time
event_time <- rexp(1, rate=k*(k-1+rho)/2)
t <- c(t, event_time)
t_sum <- t_sum + event_time
# sample whether the event is a coalescent
p_coale <- rbinom(n=1, size=1, prob=(k-1)/(k-1+rho))
if (p_coale == 1) {
# coalescent event
leaf_node <- sample(pool, size=2, replace=FALSE)
# append edges
edge_matrix[c(edge_index, edge_index+1), 1] <- next_node
edge_matrix[c(edge_index, edge_index+1), 2] <- leaf_node
edge_matrix[c(edge_index, edge_index+1), 3] <- t_sum-node_height[leaf_node]
edge_mat[c(edge_index, edge_index+1), ] <- node_mat[leaf_node, ]
# append root node
node_height[node_index] <- t_sum
node_mat[node_index, ] <- as.integer(node_mat[leaf_node[1], ] |
node_mat[leaf_node[2], ])
# updates for iteration
edge_index <- edge_index + 2
node_index <- node_index + 1
pool <- c(setdiff(pool, leaf_node), next_node)
next_node <- next_node + 1L
k <- k - 1
} else {
# recombination event
leaf_node <- sample(pool, size=1, replace=FALSE)
if (bacteria) {
x <- which(runif(1) < probstartcum)[1]
y <- min(x + rgeom(1, 1/delta), L)
if ((sum(node_mat[leaf_node, x:y])==0 |
sum(node_mat[leaf_node, -(x:y)])==0) & optimise_recomb) {
next
}
edge_mat[c(edge_index, edge_index+1), ] <- 0
edge_mat[edge_index, x:y] <- node_mat[leaf_node, x:y]
edge_mat[edge_index+1, -(x:y)] <- node_mat[leaf_node, -(x:y)]
node_mat[c(node_index, node_index+1), ] <- 0
node_mat[node_index, x:y] <- node_mat[leaf_node, x:y]
node_mat[node_index+1, -(x:y)] <- node_mat[leaf_node, -(x:y)]
} else {
x <- which(runif(1) < probstartcum)[1]
if ((sum(node_mat[leaf_node, 1:(x-1)])==0 |
sum(node_mat[leaf_node, x:L])==0) & optimise_recomb) {
next
}
edge_mat[c(edge_index, edge_index+1), ] <- 0
edge_mat[edge_index, 1:(x-1)] <- node_mat[leaf_node, 1:(x-1)]
edge_mat[edge_index+1, x:L] <- node_mat[leaf_node, x:L]
node_mat[c(node_index, node_index+1), ] <- 0
node_mat[node_index, 1:(x-1)] <- node_mat[leaf_node, 1:(x-1)]
node_mat[node_index+1, x:L] <- node_mat[leaf_node, x:L]
}
# append edges
edge_matrix[c(edge_index, edge_index+1), 1] <- c(next_node, next_node+1L)
edge_matrix[c(edge_index, edge_index+1), 2] <- leaf_node
edge_matrix[c(edge_index, edge_index+1), 3] <- t_sum-node_height[leaf_node]
# append root node
node_height[c(node_index, node_index+1)] <- t_sum
# updates for iteration
edge_index <- edge_index + 2
node_index <- node_index + 2
pool <- c(setdiff(pool, leaf_node), next_node, next_node+1L)
next_node <- next_node + 2L
k <- k + 1
}
k_vector <- c(k_vector, k)
if (max(edge_index, next_node, node_index) >= node_max - 1) {
# add empty rows or elements if more edges than expected
edge_matrix <- rbind(edge_matrix, matrix(NA, nrow=node_max, ncol=3))
edge_mat <- rbind(edge_mat, matrix(NA, nrow=node_max, ncol=L))
node_height <- c(node_height, rep(NA, node_max))
node_mat <- rbind(node_mat, matrix(NA, nrow=node_max, ncol=L))
node_max <- 2 * node_max
}
}
ARG = list(edge=edge_matrix[complete.cases(edge_matrix), ],
edge_mat=edge_mat[complete.cases(edge_mat), ],
node_height=node_height[!is.na(node_height)],
node_mat=node_mat[complete.cases(node_mat), ],
waiting_time=t, sum_time=t_sum, k=k_vector, n=n, rho=rho, L=L,
bacteria=bacteria, delta=delta)
class(ARG) <- "sim_FSM_ARG"
})
profvis({
n = 100
rho = 5
L = 100
bacteria = TRUE
delta = 10
node_max = 100000
optimise_recomb = TRUE
if (n!=as.integer(n)) {
stop("Sample size must be an integer")
} else if (L!=as.integer(L)) {
stop("Number of sites must be an integer")
} else if (bacteria & is.null(delta)) {
stop("Must provide parameter for the length of recombinant segment")
} else if (n >= node_max) {
stop("Maximal node size must greater than the number of leaf lineages")
}
k = n
k_vector <- c(k)
t <- vector("numeric", length = 0) # vector of event times
t_sum <- 0
edge_matrix <- matrix(NA, nrow=node_max, ncol=3) # root and leaf nodes, length
colnames(edge_matrix) <- c("node1", "node2", "length")
edge_mat <- matrix(NA, nrow=node_max, ncol=L)    # edge material
node_height <- rep(NA, node_max)                 # node height to recent time
node_mat <- matrix(NA, nrow=node_max, ncol=L)    # node material
node_height[1:n] <- 0                            # initialize first n nodes
node_mat[1:n, ] <- 1
# Probability of starting recombination at each site
probstart <- rep(1, L)
if (bacteria) {probstart[1] <- delta}
probstart <- probstart / sum(probstart)
probstartcum <- cumsum(probstart)
# Initialize variables and vector
edge_index <- 1
node_index <- n + 1
pool <- as.integer(1:n)
next_node <- as.integer(n+1)
while (k > 1) {
# sample a new event time
event_time <- rexp(1, rate=k*(k-1+rho)/2)
t <- c(t, event_time)
t_sum <- t_sum + event_time
# sample whether the event is a coalescent
p_coale <- rbinom(n=1, size=1, prob=(k-1)/(k-1+rho))
if (p_coale == 1) {
# coalescent event
leaf_node <- sample(pool, size=2, replace=FALSE)
# append edges
edge_matrix[c(edge_index, edge_index+1), 1] <- next_node
edge_matrix[c(edge_index, edge_index+1), 2] <- leaf_node
edge_matrix[c(edge_index, edge_index+1), 3] <- t_sum-node_height[leaf_node]
edge_mat[c(edge_index, edge_index+1), ] <- node_mat[leaf_node, ]
# append root node
node_height[node_index] <- t_sum
node_mat[node_index, ] <- as.integer(node_mat[leaf_node[1], ] |
node_mat[leaf_node[2], ])
# updates for iteration
edge_index <- edge_index + 2
node_index <- node_index + 1
pool <- c(setdiff(pool, leaf_node), next_node)
next_node <- next_node + 1L
k <- k - 1
} else {
# recombination event
leaf_node <- sample(pool, size=1, replace=FALSE)
if (bacteria) {
x <- which(runif(1) < probstartcum)[1]
y <- min(x + rgeom(1, 1/delta), L)
if ((sum(node_mat[leaf_node, x:y])==0 |
sum(node_mat[leaf_node, -(x:y)])==0) & optimise_recomb) {
next
}
edge_mat[c(edge_index, edge_index+1), ] <- 0
edge_mat[edge_index, x:y] <- node_mat[leaf_node, x:y]
edge_mat[edge_index+1, -(x:y)] <- node_mat[leaf_node, -(x:y)]
node_mat[c(node_index, node_index+1), ] <- 0
node_mat[node_index, x:y] <- node_mat[leaf_node, x:y]
node_mat[node_index+1, -(x:y)] <- node_mat[leaf_node, -(x:y)]
} else {
x <- which(runif(1) < probstartcum)[1]
if ((sum(node_mat[leaf_node, 1:(x-1)])==0 |
sum(node_mat[leaf_node, x:L])==0) & optimise_recomb) {
next
}
edge_mat[c(edge_index, edge_index+1), ] <- 0
edge_mat[edge_index, 1:(x-1)] <- node_mat[leaf_node, 1:(x-1)]
edge_mat[edge_index+1, x:L] <- node_mat[leaf_node, x:L]
node_mat[c(node_index, node_index+1), ] <- 0
node_mat[node_index, 1:(x-1)] <- node_mat[leaf_node, 1:(x-1)]
node_mat[node_index+1, x:L] <- node_mat[leaf_node, x:L]
}
# append edges
edge_matrix[c(edge_index, edge_index+1), 1] <- c(next_node, next_node+1L)
edge_matrix[c(edge_index, edge_index+1), 2] <- leaf_node
edge_matrix[c(edge_index, edge_index+1), 3] <- t_sum-node_height[leaf_node]
# append root node
node_height[c(node_index, node_index+1)] <- t_sum
# updates for iteration
edge_index <- edge_index + 2
node_index <- node_index + 2
pool <- c(setdiff(pool, leaf_node), next_node, next_node+1L)
next_node <- next_node + 2L
k <- k + 1
}
k_vector <- c(k_vector, k)
if (max(edge_index, next_node, node_index) >= node_max - 1) {
# add empty rows or elements if more edges than expected
edge_matrix <- rbind(edge_matrix, matrix(NA, nrow=node_max, ncol=3))
edge_mat <- rbind(edge_mat, matrix(NA, nrow=node_max, ncol=L))
node_height <- c(node_height, rep(NA, node_max))
node_mat <- rbind(node_mat, matrix(NA, nrow=node_max, ncol=L))
node_max <- 2 * node_max
}
}
ARG = list(edge=edge_matrix[1:(edge_index-1), ],
edge_mat=edge_mat[1:(edge_index-1), ],
node_height=node_height[1:(node_index-1)],
node_mat=node_mat[1:(node_index-1), ],
waiting_time=t, sum_time=t_sum, k=k_vector, n=n, rho=rho, L=L,
bacteria=bacteria, delta=delta)
class(ARG) <- "sim_FSM_ARG"
})
profvis({
n=100
rho = 5
delta = 1
blocks = c(100)
optimise = T
# This function simulates the coalescent with recombination
# It is optimized using the concept of ancestral material
L <- sum(blocks)                        # Total length of the data
delta <- 1 / delta                      # Inverse of average tract length
blockscum <- cumsum(blocks)            # Cumulative block lengths
# Probability of starting recombination at each site
probstart <- rep(1, L)
loc <- 1
for (i in seq_along(blocks)) {
probstart[loc] <- 1 / delta
loc <- loc + blocks[i]
}
probstart <- probstart / sum(probstart)
probstartcum <- cumsum(probstart)
# Initialize ARG data structures
max_nodes <- 100000
s <- matrix(0L, nrow = max_nodes, ncol = 6)      # s: nodes with [child1, child2, clonal parent, imported parent, start, end]
ages <- rep(0, max_nodes)                        # Ages of nodes
toCoal <- rep(0L, 10 * n)                        # Remaining lineages
toCoalAncMat <- matrix(0L, nrow = L, ncol = 10 * n)  # Which sites are ancestral material
toCoal[1:n] <- 1:n
toCoalAncMat[, 1:n] <- 1                         # Initially, everything is ancestral material
ancmat <- matrix(0L, nrow = L + 1, ncol = max_nodes)
ancmat[, 1:n] <- 1                               # Full ancestry matrix
nodes <- n                                       # Initial number of nodes
k <- n                                           # Number of lineages
time <- 0                                        # Time tracker
eq <- 1                                          # Flag for recombination across segments
while (k > 1) {
# Time until next event
time <- time - log(runif(1)) / (k * (k - 1) / 2 + k * rho / 2)
if (runif(1) < (k - 1) / (k - 1 + rho)) {
# Coalescent event
i <- sample(1:k, 1)
j <- sample(setdiff(1:k, i), 1)
nodes <- nodes + 1
s[nodes, 1:2] <- c(toCoal[i], toCoal[j])
s[toCoal[i], 3] <- nodes
s[toCoal[j], 3] <- nodes
ages[nodes] <- time
if (sum(toCoalAncMat[, i] & toCoalAncMat[, j]) > 0 &&
sum(toCoalAncMat[, i] & toCoalAncMat[, j]) < L) eq <- 0
# Merge ancestral material
toCoalAncMat[, i] <- toCoalAncMat[, i] | toCoalAncMat[, j]
ancmat[1:L, nodes] <- toCoalAncMat[, i]
ancmat[L + 1, nodes] <- ancmat[L + 1, toCoal[i]] | ancmat[L + 1, toCoal[j]]
# Update lineage list
toCoal[i] <- nodes
toCoal[j] <- toCoal[k]
toCoal[k] <- 0
toCoalAncMat[, j] <- toCoalAncMat[, k]
k <- k - 1
} else {
# Recombination event
i <- sample(1:k, 1)
beg <- which(runif(1) < probstartcum)[1]
b <- which(beg <= blockscum)[1]
nd <- min(beg + rgeom(1, delta), blockscum[b])
# Skip if recombination doesn't affect ancestral material
if (optimise &&
(all(toCoalAncMat[beg:nd, i] == 0) ||
all(toCoalAncMat[-(beg:nd), i] == 0))) next
nodes <- nodes + 2
s[nodes - 1, 1] <- toCoal[i]
s[nodes, 1] <- toCoal[i]
s[toCoal[i], 3:4] <- c(nodes - 1, nodes)
s[nodes, 5:6] <- c(beg, nd)
# Split ancestry
toCoalAncMatSet <- rep(0L, L)
toCoalAncMatSet[beg:nd] <- toCoalAncMat[beg:nd, i]
toCoalAncMat[beg:nd, i] <- 0
toCoalAncMat[, k + 1] <- toCoalAncMatSet
ancmat[1:L, nodes - 1] <- toCoalAncMat[, i]
ancmat[1:L, nodes] <- toCoalAncMatSet
ancmat[L + 1, nodes - 1] <- ancmat[L + 1, toCoal[i]]
toCoal[i] <- nodes - 1
toCoal[k + 1] <- nodes
k <- k + 1
}
}
# Finalize
s <- s[1:nodes, , drop = FALSE]
ages <- ages[1:nodes]
ancmat <- ancmat[, 1:nodes, drop = FALSE]
})
#' bacteria recombination or not,
#' if yes, delta is mean of the length of recombinant segment,
#' initial maximal node size (default = 1000),
#' optimise recombination edges or not
#' Create a full ARG with coalescent and recombination
#' Edge dataframe: root node, leaf node, edge length, edge material interval
#' Node dataframe: node index, node height, node material interval
#' Output: edge dataframe, node dataframe, waiting time for each event,
#' total time, number of lineages at each event time, number of leaf alleles,
#' recombination parameter, bacteria recombination or not, and parameter delta
sim_FSM_ARG2 <- function(n, rho, L, bacteria=FALSE, delta=NULL, node_max=1000, optimise_recomb=FALSE) {
if (n!=as.integer(n)) {
stop("Sample size must be an integer")
} else if (L!=as.integer(L)) {
stop("Number of sites must be an integer")
} else if (bacteria & is.null(delta)) {
stop("Must provide parameter for the length of recombinant segment")
} else if (n >= node_max) {
stop("Maximal node size must greater than the number of leaf lineages")
}
k = n
k_vector <- c(k)
t <- vector("numeric", length = 0) # vector of event times
t_sum <- 0
edge_matrix <- matrix(NA, nrow=node_max, ncol=3) # root and leaf nodes, length
colnames(edge_matrix) <- c("node1", "node2", "length")
edge_mat <- matrix(NA, nrow=node_max, ncol=L)    # edge material
node_height <- rep(NA, node_max)                 # node height to recent time
node_mat <- matrix(NA, nrow=node_max, ncol=L)    # node material
node_height[1:n] <- 0                            # initialize first n nodes
node_mat[1:n, ] <- 1
# Probability of starting recombination at each site
probstart <- rep(1, L)
if (bacteria) {probstart[1] <- delta}
probstart <- probstart / sum(probstart)
probstartcum <- cumsum(probstart)
# Initialize variables and vector
edge_index <- 1
node_index <- n + 1
pool <- as.integer(1:n)
next_node <- as.integer(n+1)
while (k > 1) {
# sample a new event time
event_time <- rexp(1, rate=k*(k-1+rho)/2)
t <- c(t, event_time)
t_sum <- t_sum + event_time
# sample whether the event is a coalescent
p_coale <- rbinom(n=1, size=1, prob=(k-1)/(k-1+rho))
if (p_coale == 1) {
# coalescent event
leaf_node <- sample(pool, size=2, replace=FALSE)
# append edges
edge_matrix[c(edge_index, edge_index+1), 1] <- next_node
edge_matrix[c(edge_index, edge_index+1), 2] <- leaf_node
edge_matrix[c(edge_index, edge_index+1), 3] <- t_sum-node_height[leaf_node]
edge_mat[c(edge_index, edge_index+1), ] <- node_mat[leaf_node, ]
# append root node
node_height[node_index] <- t_sum
node_mat[node_index, ] <- as.integer(node_mat[leaf_node[1], ] |
node_mat[leaf_node[2], ])
# updates for iteration
edge_index <- edge_index + 2
node_index <- node_index + 1
pool <- c(setdiff(pool, leaf_node), next_node)
next_node <- next_node + 1L
k <- k - 1
} else {
# recombination event
leaf_node <- sample(pool, size=1, replace=FALSE)
if (bacteria) {
x <- which(runif(1) < probstartcum)[1]
y <- min(x + rgeom(1, 1/delta), L)
if ((sum(node_mat[leaf_node, x:y])==0 |
sum(node_mat[leaf_node, -(x:y)])==0) & optimise_recomb) {
next
}
edge_mat[c(edge_index, edge_index+1), ] <- 0
edge_mat[edge_index, x:y] <- node_mat[leaf_node, x:y]
edge_mat[edge_index+1, -(x:y)] <- node_mat[leaf_node, -(x:y)]
node_mat[c(node_index, node_index+1), ] <- 0
node_mat[node_index, x:y] <- node_mat[leaf_node, x:y]
node_mat[node_index+1, -(x:y)] <- node_mat[leaf_node, -(x:y)]
} else {
x <- which(runif(1) < probstartcum)[1]
if ((sum(node_mat[leaf_node, 1:(x-1)])==0 |
sum(node_mat[leaf_node, x:L])==0) & optimise_recomb) {
next
}
edge_mat[c(edge_index, edge_index+1), ] <- 0
edge_mat[edge_index, 1:(x-1)] <- node_mat[leaf_node, 1:(x-1)]
edge_mat[edge_index+1, x:L] <- node_mat[leaf_node, x:L]
node_mat[c(node_index, node_index+1), ] <- 0
node_mat[node_index, 1:(x-1)] <- node_mat[leaf_node, 1:(x-1)]
node_mat[node_index+1, x:L] <- node_mat[leaf_node, x:L]
}
# append edges
edge_matrix[c(edge_index, edge_index+1), 1] <- c(next_node, next_node+1L)
edge_matrix[c(edge_index, edge_index+1), 2] <- leaf_node
edge_matrix[c(edge_index, edge_index+1), 3] <- t_sum-node_height[leaf_node]
# append root node
node_height[c(node_index, node_index+1)] <- t_sum
# updates for iteration
edge_index <- edge_index + 2
node_index <- node_index + 2
pool <- c(setdiff(pool, leaf_node), next_node, next_node+1L)
next_node <- next_node + 2L
k <- k + 1
}
k_vector <- c(k_vector, k)
if (max(edge_index, next_node, node_index) >= node_max - 1) {
# add empty rows or elements if more edges than expected
edge_matrix <- rbind(edge_matrix, matrix(NA, nrow=node_max, ncol=3))
edge_mat <- rbind(edge_mat, matrix(NA, nrow=node_max, ncol=L))
node_height <- c(node_height, rep(NA, node_max))
node_mat <- rbind(node_mat, matrix(NA, nrow=node_max, ncol=L))
node_max <- 2 * node_max
}
}
ARG = list(edge=edge_matrix[1:(edge_index-1), ],
edge_mat=edge_mat[1:(edge_index-1), ],
node_height=node_height[1:(node_index-1)],
node_mat=node_mat[1:(node_index-1), ],
waiting_time=t, sum_time=t_sum, k=k_vector, n=n, rho=rho, L=L,
bacteria=bacteria, delta=delta)
class(ARG) <- "sim_FSM_ARG"
return(ARG)
}
set.seed(11)
ARG <- sim_FSM_ARG(5, 1, 10)
ARG <- sim_FSM_ARG2(5, 1, 10)
ARG_matrix <- as.matrix(ARG$edge[, c(1, 2)])
View(ARG_matrix)
View(ARG_matrix)
g <- graph_from_edgelist(ARG_matrix, directed = FALSE)
g <- delete_vertices(g, V(g)[degree(g) == 0])
layout_coord <- ARG_igraph(ARG)
plot.igraph(g)
plot.igraph(g, layout=layout_coord)
source("sim_gene/local_tree.r")
source("sim_gene/localtree_to_phylo.r")
source("sim_gene/ARG_igraph.r")
library(igraph)
g <- graph_from_edgelist(ARG_matrix, directed = FALSE)
g <- delete_vertices(g, V(g)[degree(g) == 0])
layout_coord <- ARG_igraph(ARG)
plot.igraph(g)
plot.igraph(g, layout=layout_coord)
ARG_mutation <- sim_FSM_mutation(ARG, 2)
ARG$edge[, 1]
ARG$edge_mat
ARG$node_mat[ARG$edge[, 1], ]
