#' input: obs, sigma, tol(vec in descendant order), kernel,
#' prior p_theta(), log-density d_theta(theta), model p_s(theta), n_iter
#' output: matrix (n_iter x length(theta)), matrix (n_iter x length(s))
if (is.null(sigma)) {sigma=diag(rep(1, length(obs)))}
theta_matrix <- matrix(NA, nrow=n_iter, ncol=length(p_theta()))
s_matrix <- matrix(NA, nrow=n_iter, ncol=length(obs))
T_tol <- length(tol)
# t = 1
for (i in 1:n_iter) {
while (TRUE) {
theta_0 <- p_theta()
s_0 <- p_s(theta_0)
k_0 <- kernel_func(obs, s_0, 1, sigma)
if (k_0<log(tol[1])) {break}
}
theta_matrix[i, ] <- theta_0
s_matrix[i, ] <- s_0
}
w <- rep(log(1/n_iter), n_iter)
tau <- 2*var(theta_matrix)w
abc_pmc <- function(obs, tol, kernel_func, p_theta, d_theta, p_s, n_iter, sigma=NULL) {
#' input: obs, sigma, tol(vec in descendant order), kernel,
#' prior p_theta(), log-density d_theta(theta), model p_s(theta), n_iter
#' output: matrix (n_iter x length(theta)), matrix (n_iter x length(s))
if (is.null(sigma)) {sigma=diag(rep(1, length(obs)))}
theta_matrix <- matrix(NA, nrow=n_iter, ncol=length(p_theta()))
s_matrix <- matrix(NA, nrow=n_iter, ncol=length(obs))
T_tol <- length(tol)
# t = 1
for (i in 1:n_iter) {
while (TRUE) {
theta_0 <- p_theta()
s_0 <- p_s(theta_0)
k_0 <- kernel_func(obs, s_0, 1, sigma)
if (k_0<log(tol[1])) {break}
}
theta_matrix[i, ] <- theta_0
s_matrix[i, ] <- s_0
}
w <- rep(log(1/n_iter), n_iter)
tau <- 2*var(theta_matrix)w
abc_pmc <- function(obs, tol, kernel_func, p_theta, d_theta, p_s, n_iter, sigma=NULL) {
#' input: obs, sigma, tol(vec in descendant order), kernel,
#' prior p_theta(), log-density d_theta(theta), model p_s(theta), n_iter
#' output: matrix (n_iter x length(theta)), matrix (n_iter x length(s))
if (is.null(sigma)) {sigma=diag(rep(1, length(obs)))}
theta_matrix <- matrix(NA, nrow=n_iter, ncol=length(p_theta()))
s_matrix <- matrix(NA, nrow=n_iter, ncol=length(obs))
T_tol <- length(tol)
# t = 1
for (i in 1:n_iter) {
while (TRUE) {
theta_0 <- p_theta()
s_0 <- p_s(theta_0)
k_0 <- kernel_func(obs, s_0, 1, sigma)
if (k_0<log(tol[1])) {break}
}
theta_matrix[i, ] <- theta_0
s_matrix[i, ] <- s_0
}
w <- rep(log(1/n_iter), n_iter)
tau <- 2*var(theta_matrix)w
abc_pmc <- function(obs, tol, kernel_func, p_theta, d_theta, p_s, n_iter, sigma=NULL) {
#' input: obs, sigma, tol(vec in descendant order), kernel,
#' prior p_theta(), log-density d_theta(theta), model p_s(theta), n_iter
#' output: matrix (n_iter x length(theta)), matrix (n_iter x length(s))
if (is.null(sigma)) {sigma=diag(rep(1, length(obs)))}
theta_matrix <- matrix(NA, nrow=n_iter, ncol=length(p_theta()))
s_matrix <- matrix(NA, nrow=n_iter, ncol=length(obs))
T_tol <- length(tol)
# t = 1
for (i in 1:n_iter) {
while (TRUE) {
theta_0 <- p_theta()
s_0 <- p_s(theta_0)
k_0 <- kernel_func(obs, s_0, 1, sigma)
if (k_0<log(tol[1])) {break}
}
theta_matrix[i, ] <- theta_0
s_matrix[i, ] <- s_0
}
w <- rep(log(1/n_iter), n_iter)
tau <- 2*var(theta_matrix)w
abc_pmc <- function(obs, tol, kernel_func, p_theta, d_theta, p_s, n_iter, sigma=NULL) {
#' input: obs, sigma, tol(vec in descendant order), kernel,
#' prior p_theta(), log-density d_theta(theta), model p_s(theta), n_iter
#' output: matrix (n_iter x length(theta)), matrix (n_iter x length(s))
if (is.null(sigma)) {sigma=diag(rep(1, length(obs)))}
theta_matrix <- matrix(NA, nrow=n_iter, ncol=length(p_theta()))
s_matrix <- matrix(NA, nrow=n_iter, ncol=length(obs))
T_tol <- length(tol)
# t = 1
for (i in 1:n_iter) {
while (TRUE) {
theta_0 <- p_theta()
s_0 <- p_s(theta_0)
k_0 <- kernel_func(obs, s_0, 1, sigma)
if (k_0<log(tol[1])) {break}
}
theta_matrix[i, ] <- theta_0
s_matrix[i, ] <- s_0
}
w <- rep(log(1/n_iter), n_iter)
tau <- 2*var(theta_matrix)
for (t in 2:T_tol) {
theta_1_matrix <- matrix(NA, nrow=n_iter, ncol=length(p_theta()))
w_1 <- rep(NA, n_iter)
for (i in 1:n_iter) {
theta_index <- sample(1:n_iter, 1, prob=exp(w))
while (TRUE) {
theta_0 <- rmvnorm(n=1, mean=theta_matrix[theta_index, ], sigma=tau)
s_0 <- p_s(theta_0)
k_0 <- kernel_func(obs, s_0, 1, sigma)
if (k_0<log(tol[t])) {break}
}
w_1[i] <- d_theta(theta_0) -
logSumExp(w+dmvnorm((as.numeric(theta_0)-theta_matrix), sigma=tau,
log=TRUE)+c(log(sqrt(tau))))
theta_1_matrix[i, ] <- theta_0
s_matrix[i, ] <- s_0
}
w <- w_1 - logSumExp(w_1)
theta_matrix <- theta_1_matrix
print(var(theta_matrix))
# tau <- sqrt(2*var(theta_matrix))
tau <- sqrt(2*cov.wt(theta_matrix, wt=exp(w)))
}
return(list(theta_matrix=theta_matrix, s_matrix=s_matrix))
}
mu <- 0
# observation
s_obs <- mean(rnorm(10, mean=mu, sd=1))
# simulations
mu_vec <- runif(100, min=-2, max=2)
s_vec <- c()
for (i in 1:length(mu_vec)) {
s_i <- mean(rnorm(10, mean=mu_vec[i]), sd=1)
s_vec <- c(s_vec, s_i)
}
library(ggplot2)
setwd("C:/Users/u2008181/mini_project")
source("abc_functions/abc_rejection.r")
source("abc_functions/abc_knn.r")
source("abc_functions/abc_mcmc.r")
source("abc_functions/abc_pmc.r")
source("abc_functions/abc_llr.r")
mu <- 0
# observation
s_obs <- mean(rnorm(10, mean=mu, sd=1))
# simulations
mu_vec <- runif(100, min=-2, max=2)
s_vec <- c()
for (i in 1:length(mu_vec)) {
s_i <- mean(rnorm(10, mean=mu_vec[i]), sd=1)
s_vec <- c(s_vec, s_i)
}
# proposal function
p_theta <- function() {
runif(1, min=-2, max=2)
}
d_theta <- function(theta) {
if (theta < 2 & theta > -2) {return(log(1/4))}
return(log(0))
}
# model sample
p_s <- function(theta) {
mean(rnorm(10, mean=theta), sd=1)
}
# list of tolerance
tol <- c(10, 2, 1.5, 1, 0.5)
matrix_list <- abc_pmc(c(s_obs), tol, gaussian_kernel, p_theta, d_theta, p_s, 1000)
library(ggplot2)
setwd("C:/Users/u2008181/mini_project")
source("abc_functions/abc_rejection.r")
source("abc_functions/abc_knn.r")
source("abc_functions/abc_mcmc.r")
source("abc_functions/abc_pmc.r")
source("abc_functions/abc_llr.r")
mu <- 0
# observation
s_obs <- mean(rnorm(10, mean=mu, sd=1))
# simulations
mu_vec <- runif(100, min=-2, max=2)
s_vec <- c()
for (i in 1:length(mu_vec)) {
s_i <- mean(rnorm(10, mean=mu_vec[i]), sd=1)
s_vec <- c(s_vec, s_i)
}
# proposal function
p_theta <- function(theta_0) {
runif(1, min=-2, max=2)
}
d_theta <- function(theta_1, theta_0) {
if (theta_1 < 2 & theta_1 > -2) {return(log(1/4))}
return(log(0))
}
# model sample
p_s <- function(theta) {
mean(rnorm(10, mean=theta), sd=1)
}
# initial theta
mu_0 <- runif(1, min=-2, max=2)
# M-H
matrix_list <- abc_mcmc(c(s_obs), 0.01, gaussian_kernel, p_theta, d_theta, p_s, d_theta, mu_0, 10000)
# hist of posterior
hist(matrix_list$theta_matrix[5000:10001, ], probability = TRUE, main = "Histogram of mu|s_obs",
breaks = 20, col = "gray", border = "black", xlab="mu")
abline(v = s_obs, col = "red", lwd = 2, lty = 2)
# proposal function
p_theta <- function() {
runif(1, min=-2, max=2)
}
d_theta <- function(theta) {
if (theta < 2 & theta > -2) {return(log(1/4))}
return(log(0))
}
# model sample
p_s <- function(theta) {
mean(rnorm(10, mean=theta), sd=1)
}
# list of tolerance
tol <- c(10, 2, 1.5, 1, 0.5)
matrix_list <- abc_pmc(c(s_obs), tol, gaussian_kernel, p_theta, d_theta, p_s, 1000)
library(ggplot2)
setwd("C:/Users/u2008181/mini_project")
source("abc_functions/abc_rejection.r")
source("abc_functions/abc_knn.r")
source("abc_functions/abc_mcmc.r")
source("abc_functions/abc_pmc.r")
source("abc_functions/abc_llr.r")
mu <- 0
# observation
s_obs <- mean(rnorm(10, mean=mu, sd=1))
# simulations
mu_vec <- runif(100, min=-2, max=2)
s_vec <- c()
for (i in 1:length(mu_vec)) {
s_i <- mean(rnorm(10, mean=mu_vec[i]), sd=1)
s_vec <- c(s_vec, s_i)
}
# proposal function
p_theta <- function() {
runif(1, min=-2, max=2)
}
d_theta <- function(theta) {
if (theta < 2 & theta > -2) {return(log(1/4))}
return(log(0))
}
# model sample
p_s <- function(theta) {
mean(rnorm(10, mean=theta), sd=1)
}
# list of tolerance
tol <- c(10, 2, 1.5, 1, 0.5)
matrix_list <- abc_pmc(c(s_obs), tol, gaussian_kernel, p_theta, d_theta, p_s, 1000)
library(ggplot2)
setwd("C:/Users/u2008181/mini_project")
source("abc_functions/abc_rejection.r")
source("abc_functions/abc_knn.r")
source("abc_functions/abc_mcmc.r")
source("abc_functions/abc_pmc.r")
source("abc_functions/abc_llr.r")
# proposal function
p_theta <- function() {
runif(1, min=-2, max=2)
}
d_theta <- function(theta) {
if (theta < 2 & theta > -2) {return(log(1/4))}
return(log(0))
}
# model sample
p_s <- function(theta) {
mean(rnorm(10, mean=theta), sd=1)
}
# list of tolerance
tol <- c(10, 2, 1.5, 1, 0.5)
matrix_list <- abc_pmc(c(s_obs), tol, gaussian_kernel, p_theta, d_theta, p_s, 1000)
(xy <- cbind(x = 1:10, y = c(1:3, 8:5, 8:10)))
w1 <- c(0,0,0,1,1,1,1,1,0,0)
cov.wt(xy, wt = w1)
cov.wt(xy, wt = w1)$cov
cov.wt(xy, wt = w1)$cov * 2
as.matrix(cov.wt(xy, wt = w1)$cov)
library(ggplot2)
setwd("C:/Users/u2008181/mini_project")
source("abc_functions/abc_rejection.r")
source("abc_functions/abc_knn.r")
source("abc_functions/abc_mcmc.r")
source("abc_functions/abc_pmc.r")
source("abc_functions/abc_llr.r")
# proposal function
p_theta <- function() {
runif(1, min=-2, max=2)
}
d_theta <- function(theta) {
if (theta < 2 & theta > -2) {return(log(1/4))}
return(log(0))
}
# model sample
p_s <- function(theta) {
mean(rnorm(10, mean=theta), sd=1)
}
# list of tolerance
tol <- c(10, 2, 1.5, 1, 0.5)
matrix_list <- abc_pmc(c(s_obs), tol, gaussian_kernel, p_theta, d_theta, p_s, 1000)
# hist of posterior
hist(matrix_list$theta_matrix, probability = TRUE, main = "Histogram of mu|s_obs",
breaks = 20, col = "gray", border = "black", xlab="mu")
abline(v = s_obs, col = "red", lwd = 2, lty = 2)
library(ggplot2)
setwd("C:/Users/u2008181/mini_project")
source("abc_functions/abc_rejection.r")
source("abc_functions/abc_knn.r")
source("abc_functions/abc_mcmc.r")
source("abc_functions/abc_pmc.r")
source("abc_functions/abc_llr.r")
# proposal function
p_theta <- function() {
runif(1, min=-2, max=2)
}
d_theta <- function(theta) {
if (theta < 2 & theta > -2) {return(log(1/4))}
return(log(0))
}
# model sample
p_s <- function(theta) {
mean(rnorm(10, mean=theta), sd=1)
}
# list of tolerance
tol <- c(10, 2, 1.5, 1, 0.5)
matrix_list <- abc_pmc(c(s_obs), tol, gaussian_kernel, p_theta, d_theta, p_s, 1000)
# hist of posterior
hist(matrix_list$theta_matrix, probability = TRUE, main = "Histogram of mu|s_obs",
breaks = 20, col = "gray", border = "black", xlab="mu")
abline(v = s_obs, col = "red", lwd = 2, lty = 2)
#| label: load-packages
#| include: false
library(ivs)
library(tibble)
library(dplyr)
library(igraph)
#| echo: true
#| code-fold: true
#| code-summary: "expand for full code"
source("sim_gene/sim_ARG.r")
set.seed(10)
tree <- sim_ARG(5, 1)
tree_matrix <- as.matrix(tree$edge[, c(1, 2)])
g <- graph_from_edgelist(tree_matrix, directed = FALSE)
g <- delete_vertices(g, V(g)[degree(g) == 0])
plot(g)
library(ape)
set.seed(10)
tree <- sim_ARG(5, 1)
tree_matrix <- as.matrix(tree$edge[, c(1, 2)])
g <- graph_from_edgelist(tree_matrix, directed = FALSE)
g <- delete_vertices(g, V(g)[degree(g) == 0])
plot(g)
#| label: load-packages
#| include: false
library(ivs)
library(tibble)
library(dplyr)
library(igraph)
library(ggplot2)
library(purrr)
library(deSolve)
#| echo: true
#| code-fold: true
#| code-summary: "expand for full code"
source("sim_gene/sim_ARG.r")
set.seed(10)
tree <- sim_ARG(5, 1)
tree_matrix <- as.matrix(tree$edge[, c(1, 2)])
g <- graph_from_edgelist(tree_matrix, directed = FALSE)
g <- delete_vertices(g, V(g)[degree(g) == 0])
plot(g)
#| include: false
n_trees <- 10
n <- 20
rho <- 1
tree_list <- map(1:n_trees, function(i) {
tree <- sim_ARG(n, rho)
x_values <- cumsum(c(0, tree$waiting_time))
y_values <- tree$k
tibble(
x = x_values,
y = y_values,
id = paste0("ARG_", i) # Identifier for each step function
)
})
step_df <- bind_rows(tree_list)
ODE_process <- function(x, state, parameters) {
with(as.list(c(state, parameters)), {
# ODE: dy/dx = (rho * y - y^2 + y) / 2
dy_dx <- (rho * y - y^2 + y) / 2
return(list(c(dy_dx)))
})
}
initial_y <- c(y = n)
x_values <- seq(0, 2*max(step_df$x), by = 0.1)
ode_parameters <- c(rho = rho)
ode_solution <- ode(
y = initial_y,
times = x_values,
func = ODE_process,
parms = ode_parameters
)
ode_df <- as_tibble(ode_solution)
colnames(ode_df)[1] <- "x"
ggplot() +
# 10 step functions
geom_step(data = step_df, aes(x = x, y = y, group = id, color = id),
size = 0.7, alpha = 0.7) +
# one continuous function
geom_line(data = ode_df, aes(x = x, y = y), color = "black",
linetype = "solid", size = 1.2) +
labs(
title = "Birth and Death Process",
x = "Time",
y = "Number of alleles",
color = "ARG ID"
) +
theme_minimal() +
guides(color = guide_legend(ncol = 2))
#| echo: false
n_trees <- 10
n <- 20
rho <- 1
tree_list <- map(1:n_trees, function(i) {
tree <- sim_ARG(n, rho)
x_values <- cumsum(c(0, tree$waiting_time))
y_values <- tree$k
tibble(
x = x_values,
y = y_values,
id = paste0("ARG_", i) # Identifier for each step function
)
})
step_df <- bind_rows(tree_list)
ODE_process <- function(x, state, parameters) {
with(as.list(c(state, parameters)), {
# ODE: dy/dx = (rho * y - y^2 + y) / 2
dy_dx <- (rho * y - y^2 + y) / 2
return(list(c(dy_dx)))
})
}
initial_y <- c(y = n)
x_values <- seq(0, 2*max(step_df$x), by = 0.1)
ode_parameters <- c(rho = rho)
ode_solution <- ode(
y = initial_y,
times = x_values,
func = ODE_process,
parms = ode_parameters
)
ode_df <- as_tibble(ode_solution)
colnames(ode_df)[1] <- "x"
ggplot() +
# 10 step functions
geom_step(data = step_df, aes(x = x, y = y, group = id, color = id),
size = 0.7, alpha = 0.7) +
# one continuous function
geom_line(data = ode_df, aes(x = x, y = y), color = "black",
linetype = "solid", size = 1.2) +
labs(
title = "Birth and Death Process",
x = "Time",
y = "Number of alleles",
color = "ARG ID"
) +
theme_minimal() +
guides(color = guide_legend(ncol = 2))
#| echo: true
#| code-fold: true
#| code-summary: "expand for full code"
source("sim_gene/sim_mutation.r")
tree_mutation <- sim_mutation(tree, 2)
tree_mutation$node
View(tree_mutation)
tree_mutation$mutation
tree_mutation$node$gene
View(tree_mutation)
tree_mutation$edge
#| echo: true
#| code-fold: true
#| code-summary: "expand for full code"
source("sim_gene/sim_mutation.r")
tree_mutation <- sim_mutation(tree, 2)
tree_mutation$node
#| echo: true
#| code-fold: true
#| code-summary: "expand for full code"
local_tree <- local_ARG(tree, 0.5)
#| echo: true
#| code-fold: true
#| code-summary: "expand for full code"
source("sim_gene/local_ARG.r")
local_tree <- local_ARG(tree, 0.5)
local_tree_matrix <- as.matrix(local_tree$edge[, c(1, 2)])
local_g <- graph_from_edgelist(local_tree_matrix, directed = FALSE)
local_g <- delete_vertices(local_g, V(local_g)[degree(local_g) == 0])
plot(local_g)
library(ape)
ape::plot.phylo
#| echo: true
#| code-fold: true
#| code-summary: "expand for full code"
library(ape)
source("sim_gene/localARG_to_phylo.r")
phylo_tree <- localARG_to_phylo(local_tree)
plot(phylo_tree)
