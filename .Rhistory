#' Edge dataframe: root node, leaf node, edge length, edge material interval
#' Node dataframe: node index, node height, node material interval
#' Output: edge dataframe, node dataframe, waiting time for each event,
#' total time, number of lineages at each event time, number of leaf alleles,
#' recombination parameter, bacteria recombination or not, and parameter delta
simbac_ARG <- function(n, rho, L, delta, node_max=1000, output_eff_R=FALSE, optimise_site=FALSE) {
if (n!=as.integer(n)) {
stop("Sample size must be an integer")
} else if (L!=as.integer(L)) {
stop("Number of sites must be an integer")
} else if (n >= node_max) {
stop("Maximal node size must greater than the number of leaf lineages")
}
k = n
k_vector <- c(k)
t <- vector("numeric", length = 0) # vector of event times
t_sum <- 0
edge_matrix <- matrix(NA, nrow=node_max, ncol=3)    # root and leaf nodes, length
colnames(edge_matrix) <- c("node1", "node2", "length")
edge_mat_index <- rep(NA, node_max)                 # edge material index
node_height <- rep(NA, node_max)                    # node height to recent time
node_mat <- matrix(NA, nrow=node_max, ncol=L)       # node material
node_eff_R <- matrix(NA, nrow=node_max, ncol=2)     # node effective R
colnames(node_eff_R) <- c("effective_R", "clonal")
node_probstart <- matrix(NA, nrow=node_max, ncol=L) # node recomb starting prob
node_height[1:n] <- 0                               # initialize nodes height
node_mat[1:n, ] <- 1                                # initialize nodes material
node_eff_R[1:n, 1] <- rho * (1-(1-1/delta)^(L-1))   # initialize effective R
node_eff_R[1:n, 2] <- TRUE
node_probstart[1:n, ] <- matrix(cumsum(rep(1/L, L)), nrow=n, ncol=L, byrow=TRUE)
# Initialize variables and vector
edge_index <- 1
node_index <- n + 1
pool <- as.integer(1:n)
next_node <- as.integer(n+1)
if (optimise_site) {include_site <- rep(TRUE, L)}
while (k > 1) {
# sample a new event time
rho_eff <- sum(node_eff_R[pool, 1])
event_time <- rexp(1, rate=(k*(k-1)+rho_eff)/2)
t <- c(t, event_time)
t_sum <- t_sum + event_time
# sample whether the event is a coalescent
p_coale <- rbinom(n=1, size=1, prob=k*(k-1)/(k*(k-1)+rho_eff))
if (p_coale == 1) {
# coalescent event
leaf_node <- sample(pool, size=2, replace=FALSE)
# append edges
edge_matrix[c(edge_index, edge_index+1), 1] <- next_node
edge_matrix[c(edge_index, edge_index+1), 2] <- leaf_node
edge_matrix[c(edge_index, edge_index+1), 3] <- t_sum-node_height[leaf_node]
edge_mat_index[c(edge_index, edge_index+1)] <- leaf_node
# append root node
node_height[node_index] <- t_sum
node_mat[node_index, ] <- as.integer(node_mat[leaf_node[1], ] |
node_mat[leaf_node[2], ])
# update effective R
node_eff_R[node_index, 2] <- any(as.logical(node_eff_R[leaf_node, 2]))
if (optimise_site) {
list_eff_R <- effective_R(node_mat[node_index, ], delta, rho,
node_eff_R[node_index, 2], include_site=include_site)
} else {
list_eff_R <- effective_R(node_mat[node_index, ], delta, rho,
node_eff_R[node_index, 2])
}
node_eff_R[node_index, 1] <- list_eff_R$R_eff
node_probstart[node_index, ] <- list_eff_R$probstartcum
# updates for iteration
edge_index <- edge_index + 2
node_index <- node_index + 1
pool <- c(setdiff(pool, leaf_node), next_node)
next_node <- next_node + 1L
k <- k - 1
if (optimise_site & any(include_site)) {
# check if contain exclude sites
include_site_index <- which(include_site)
for (i in 1:sum(include_site)) {
if (sum(node_mat[pool, include_site_index[i]]) == 1) {
include_site[include_site_index[i]] <- FALSE
for (j in pool) {
list_eff_R <- effective_R(node_mat[j, ], delta, rho,
node_eff_R[j, 2],
include_site=include_site)
node_eff_R[j, 1] <- list_eff_R$R_eff
node_probstart[j, ] <- list_eff_R$probstartcum
}
}
}
}
} else {
# recombination event
leaf_node <- sample(pool, size=1, replace=FALSE, prob=node_eff_R[pool, 1])
# sample recombination segment
x <- which(runif(1) < node_probstart[leaf_node, ])[1]
# pmf for conditional geom distribution
v_s <- which(node_mat[leaf_node, ] &
(node_mat[leaf_node, ] != c(0, node_mat[leaf_node, ][1:(L-1)])))
site_index <- which(v_s %in% x)
if (length(site_index)) {
v_e <- which(node_mat[leaf_node, ] &
(node_mat[leaf_node, ] != c(node_mat[leaf_node, ][2:L], 0)))
v_e <- c(v_e[length(v_e)] - L, v_e)
s <- min(L - (v_s[site_index] - v_e[site_index]), L - x + 1)
} else {s <- L - x + 1}
r_pmf <- (1 - 1/delta)^(1:s - 1) / (delta * (1 - (1 - 1/delta)^s))
y <- which(runif(1) < cumsum(r_pmf))[1] + x - 1
# repeat {
#   x <- which(runif(1) < node_probstart[leaf_node, ])[1]
#   y <- min(x + rgeom(1, 1/delta), L)
#   if ((!(sum(node_mat[leaf_node, x:y])==0 |
#          sum(node_mat[leaf_node, -(x:y)])==0)) &
#       (!node_eff_R[leaf_node, 2])) {
#     break
#   } else if ((!(sum(node_mat[leaf_node, x:y])==0)) &
#              node_eff_R[leaf_node, 2]) {
#     break
#   }
# }
edge_mat_index[c(edge_index, edge_index+1)] <- c(node_index, node_index+1)
node_mat[c(node_index, node_index+1), ] <- 0
node_mat[node_index, x:y] <- node_mat[leaf_node, x:y]
node_mat[node_index+1, -(x:y)] <- node_mat[leaf_node, -(x:y)]
# append edges
edge_matrix[c(edge_index, edge_index+1), 1] <- c(next_node, next_node+1L)
edge_matrix[c(edge_index, edge_index+1), 2] <- leaf_node
edge_matrix[c(edge_index, edge_index+1), 3] <- t_sum-node_height[leaf_node]
# append root node
node_height[c(node_index, node_index+1)] <- t_sum
# update effective R
node_eff_R[node_index, 2] <- FALSE
if (optimise_site) {
list_eff_R <- effective_R(node_mat[node_index, ], delta, rho,
node_eff_R[node_index, 2], include_site=include_site)
} else {
list_eff_R <- effective_R(node_mat[node_index, ], delta, rho,
node_eff_R[node_index, 2])
}
node_eff_R[node_index, 1] <- list_eff_R$R_eff
node_probstart[node_index, ] <- list_eff_R$probstartcum
node_eff_R[node_index+1, 2] <- node_eff_R[leaf_node, 2]
if (optimise_site) {
list_eff_R <- effective_R(node_mat[node_index+1, ], delta, rho,
node_eff_R[node_index+1, 2], include_site=include_site)
} else {
list_eff_R <- effective_R(node_mat[node_index+1, ], delta, rho,
node_eff_R[node_index+1, 2])
}
node_eff_R[node_index+1, 1] <- list_eff_R$R_eff
node_probstart[node_index+1, ] <- list_eff_R$probstartcum
# updates for iteration
edge_index <- edge_index + 2
node_index <- node_index + 2
pool <- c(setdiff(pool, leaf_node), next_node, next_node+1L)
next_node <- next_node + 2L
k <- k + 1
}
k_vector <- c(k_vector, k)
if (max(edge_index, next_node, node_index) >= node_max - 1) {
# add empty rows or elements if more edges than expected
edge_matrix <- rbind(edge_matrix, matrix(NA, nrow=node_max, ncol=3))
edge_mat_index <- c(edge_mat_index, rep(NA, node_max))
node_height <- c(node_height, rep(NA, node_max))
node_mat <- rbind(node_mat, matrix(NA, nrow=node_max, ncol=L))
node_eff_R <- rbind(node_eff_R, matrix(NA, nrow=node_max, ncol=2))
node_probstart <- rbind(node_probstart, matrix(NA, nrow=node_max, ncol=L))
node_max <- 2 * node_max
}
}
if (output_eff_R) {
ARG = list(edge=edge_matrix[1:(edge_index-1), ],
edge_mat=node_mat[edge_mat_index[1:(edge_index-1)], ],
node_height=node_height[1:(node_index-1)],
node_mat=node_mat[1:(node_index-1), ],
waiting_time=t, sum_time=t_sum, k=k_vector, n=n, rho=rho, L=L,
delta=delta, node_eff_R=node_eff_R[1:(node_index-1), ],
node_probstart=node_probstart[1:(node_index-1), ])
} else {
ARG = list(edge=edge_matrix[1:(edge_index-1), ],
edge_mat=node_mat[edge_mat_index[1:(edge_index-1)], ],
node_height=node_height[1:(node_index-1)],
node_mat=node_mat[1:(node_index-1), ],
waiting_time=t, sum_time=t_sum, k=k_vector, n=n, rho=rho, L=L,
delta=delta)
}
class(ARG) <- "sim_FSM_ARG"
return(ARG)
}
for (i in 1:1000) {
print(i)
set.seed(i)
r <- simbac_ARG(100, 5, 100, delta = 5, node_max = 100000, output_eff_R = FALSE, optimise_site = TRUE)
}
#| echo: true
time_df <- data.frame(time=rep(NA, 6000),
func=c(rep("Birth-death Process", 1000),
rep("sim_FSM_ARG(optimise_recom=T)", 1000),
rep("sim_FSM_ARG(optimise_recom=T, clonal=T))", 1000),
rep("sim_FSM_ARG(optimise_recom=F)", 1000),
rep("simbac(optimise_site=F)", 1000),
rep("simbac(optimise_site=T)", 1000)))
set.seed(10)
for (i in 1:1000) {
t <- sim_birth_death(100, 5)
time_df$time[i] <- t
r <- sim_FSM_ARG(100, 5, 100, bacteria = TRUE, delta = 5,
node_max = 100000, optimise_recomb = TRUE)
time_df$time[1000+i] <- r$sum_time
r <- sim_FSM_ARG(100, 5, 100, bacteria = TRUE, delta = 5,
node_max = 100000, optimise_recomb = TRUE, clonal = TRUE)
time_df$time[2000+i] <- r$sum_time
r <- sim_FSM_ARG(100, 5, 100, bacteria = TRUE, delta = 5,
node_max = 100000, optimise_recomb = FALSE)
time_df$time[3000+i] <- r$sum_time
r <- simbac_ARG(100, 5, 100, delta = 5, node_max = 100000, output_eff_R = FALSE)
time_df$time[4000+i] <- r$sum_time
r <- simbac_ARG(100, 5, 100, delta = 5, node_max = 100000, output_eff_R = FALSE, optimise_site = TRUE)
time_df$time[5000+i] <- r$sum_time
# if (i%%100 == 0) {print(paste("Complete", i, "iterations"))}
print(paste("Complete", i, "iterations"))
}
#| echo: true
ggplot(time_df, aes(x=func, y=time, fill=func)) +
geom_violin(width=1, alpha=0.5) +
geom_boxplot(width=0.1, color="black", alpha=0.2) +
labs(title = "# of leaf lineages = 100, rho = 5",
x = "Functions",
y = "ARG height") +
theme_minimal() +
theme(
plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
axis.title.x = element_text(size = 16),
axis.text.x = element_text(size = 12),
axis.title.y = element_text(size = 16),
axis.text.y = element_text(size = 12),
legend.title = element_text(size = 16),
legend.text = element_text(size = 12)
)
#| echo: true
height_t_df <- data.frame(s1=rep(NA, 1000),
s50=rep(NA, 1000),
s80=rep(NA, 1000))
set.seed(100)
for (i in 1:1000) {
ARG <- simbac_ARG(100, 5, 100, delta = 5, node_max = 100000, output_eff_R = TRUE, optimise_site = TRUE)
tree1 <- local_tree(ARG, 1)
tree50 <- local_tree(ARG, 50)
tree80 <- local_tree(ARG, 80)
height_t_df$s1[i] <- tree1$sum_time
height_t_df$s50[i] <- tree50$sum_time
height_t_df$s80[i] <- tree80$sum_time
if (i%%100 == 0) {print(paste("Complete", i, "iterations"))}
}
#| echo: true
n <- 100
height_rate <- n:2 * (n-1):1 / 2
height_density <- function(x) {
dhypoexp(x, rate=height_rate)
}
hist1 <- ggplot(height_t_df, aes(x = s1)) +
geom_histogram(aes(y = after_stat(density)),
bins = 30,
fill = "lightgreen",
color = "black",
alpha = 0.7) +
stat_function(fun = height_density, # Use your custom function here
color = "darkblue",
linewidth = 1.2,
linetype = "solid") +
labs(title = "Locat tree at site 1",
x = "Height",
y = "Density") +
theme_minimal()
hist2 <- ggplot(height_t_df, aes(x = s50)) +
geom_histogram(aes(y = after_stat(density)),
bins = 30,
fill = "lightgreen",
color = "black",
alpha = 0.7) +
stat_function(fun = height_density, # Use your custom function here
color = "darkblue",
linewidth = 1.2,
linetype = "solid") +
labs(title = "Locat tree at site 50",
x = "Height",
y = "Density") +
theme_minimal()
hist3 <- ggplot(height_t_df, aes(x = s80)) +
geom_histogram(aes(y = after_stat(density)),
bins = 30,
fill = "lightgreen",
color = "black",
alpha = 0.7) +
stat_function(fun = height_density, # Use your custom function here
color = "darkblue",
linewidth = 1.2,
linetype = "solid") +
labs(title = "Locat tree at site 80",
x = "Height",
y = "Density") +
theme_minimal()
combined_hist <- hist1 + hist2 + hist3
combined_hist <- combined_hist +
plot_annotation(
title = "simbac_ARG(100, 5, 100, delta = 5, node_max = 100000)")
print(combined_hist)
#| echo: true
height_t_df <- data.frame(s1=rep(NA, 1000),
s50=rep(NA, 1000),
s80=rep(NA, 1000))
set.seed(10)
for (i in 1:1000) {
ARG <- simbac_ARG(100, 5, 100, delta = 5, node_max = 100000, output_eff_R = TRUE, optimise_site = TRUE)
tree1 <- local_tree(ARG, 1)
tree50 <- local_tree(ARG, 50)
tree80 <- local_tree(ARG, 80)
height_t_df$s1[i] <- tree1$sum_time
height_t_df$s50[i] <- tree50$sum_time
height_t_df$s80[i] <- tree80$sum_time
if (i%%100 == 0) {print(paste("Complete", i, "iterations"))}
}
#| echo: true
n <- 100
height_rate <- n:2 * (n-1):1 / 2
height_density <- function(x) {
dhypoexp(x, rate=height_rate)
}
hist1 <- ggplot(height_t_df, aes(x = s1)) +
geom_histogram(aes(y = after_stat(density)),
bins = 30,
fill = "lightgreen",
color = "black",
alpha = 0.7) +
stat_function(fun = height_density, # Use your custom function here
color = "darkblue",
linewidth = 1.2,
linetype = "solid") +
labs(title = "Locat tree at site 1",
x = "Height",
y = "Density") +
theme_minimal()
hist2 <- ggplot(height_t_df, aes(x = s50)) +
geom_histogram(aes(y = after_stat(density)),
bins = 30,
fill = "lightgreen",
color = "black",
alpha = 0.7) +
stat_function(fun = height_density, # Use your custom function here
color = "darkblue",
linewidth = 1.2,
linetype = "solid") +
labs(title = "Locat tree at site 50",
x = "Height",
y = "Density") +
theme_minimal()
hist3 <- ggplot(height_t_df, aes(x = s80)) +
geom_histogram(aes(y = after_stat(density)),
bins = 30,
fill = "lightgreen",
color = "black",
alpha = 0.7) +
stat_function(fun = height_density, # Use your custom function here
color = "darkblue",
linewidth = 1.2,
linetype = "solid") +
labs(title = "Locat tree at site 80",
x = "Height",
y = "Density") +
theme_minimal()
combined_hist <- hist1 + hist2 + hist3
combined_hist <- combined_hist +
plot_annotation(
title = "simbac_ARG(100, 5, 100, delta = 5, node_max = 100000)")
print(combined_hist)
#| label: load-packages
#| include: false
library(ggplot2)
library(microbenchmark)
library(patchwork)
library(sdprisk)
source("sim_gene/FSM/sim_FSM_ARG.r")
source("sim_gene/FSM/simbac_ARG.r")
source("sim_gene/FSM/sim_FSM_mutation.r")
source("sim_gene/ref/simu.R")
source("sim_gene/sim_birth_death.r")
source("sim_gene/local_tree.r")
source("sim_gene/ARG_igraph.r")
#| echo: true
time_df <- data.frame(time=rep(NA, 6000),
func=c(rep("Birth-death Process", 1000),
rep("sim_FSM_ARG(optimise_recom=T)", 1000),
rep("sim_FSM_ARG(optimise_recom=T, clonal=T))", 1000),
rep("sim_FSM_ARG(optimise_recom=F)", 1000),
rep("simbac(optimise_site=F)", 1000),
rep("simbac(optimise_site=T)", 1000)))
set.seed(10)
for (i in 1:1000) {
t <- sim_birth_death(100, 5)
time_df$time[i] <- t
r <- sim_FSM_ARG(100, 5, 100, bacteria = TRUE, delta = 5,
node_max = 100000, optimise_recomb = TRUE)
time_df$time[1000+i] <- r$sum_time
r <- sim_FSM_ARG(100, 5, 100, bacteria = TRUE, delta = 5,
node_max = 100000, optimise_recomb = TRUE, clonal = TRUE)
time_df$time[2000+i] <- r$sum_time
r <- sim_FSM_ARG(100, 5, 100, bacteria = TRUE, delta = 5,
node_max = 100000, optimise_recomb = FALSE)
time_df$time[3000+i] <- r$sum_time
r <- simbac_ARG(100, 5, 100, delta = 5, node_max = 100000, output_eff_R = FALSE)
time_df$time[4000+i] <- r$sum_time
r <- simbac_ARG(100, 5, 100, delta = 5, node_max = 100000, output_eff_R = FALSE, optimise_site = TRUE)
time_df$time[5000+i] <- r$sum_time
if (i%%100 == 0) {print(paste("Complete", i, "iterations"))}
}
any(NULL)
#| label: load-packages
#| include: false
library(ggplot2)
library(microbenchmark)
library(patchwork)
library(sdprisk)
source("sim_gene/FSM/sim_FSM_ARG.r")
source("sim_gene/FSM/simbac_ARG.r")
source("sim_gene/FSM/sim_FSM_mutation.r")
source("sim_gene/ref/simu.R")
source("sim_gene/sim_birth_death.r")
source("sim_gene/local_tree.r")
source("sim_gene/ARG_igraph.r")
#| echo: true
time_df <- data.frame(time=rep(NA, 6000),
func=c(rep("Birth-death Process", 1000),
rep("sim_FSM_ARG(optimise_recom=T)", 1000),
rep("sim_FSM_ARG(optimise_recom=T, clonal=T))", 1000),
rep("sim_FSM_ARG(optimise_recom=F)", 1000),
rep("simbac(optimise_site=F)", 1000),
rep("simbac(optimise_site=T)", 1000)))
set.seed(10)
for (i in 1:1000) {
t <- sim_birth_death(100, 5)
time_df$time[i] <- t
r <- sim_FSM_ARG(100, 5, 100, bacteria = TRUE, delta = 5,
node_max = 100000, optimise_recomb = TRUE)
time_df$time[1000+i] <- r$sum_time
r <- sim_FSM_ARG(100, 5, 100, bacteria = TRUE, delta = 5,
node_max = 100000, optimise_recomb = TRUE, clonal = TRUE)
time_df$time[2000+i] <- r$sum_time
r <- sim_FSM_ARG(100, 5, 100, bacteria = TRUE, delta = 5,
node_max = 100000, optimise_recomb = FALSE)
time_df$time[3000+i] <- r$sum_time
r <- simbac_ARG(100, 5, 100, delta = 5, node_max = 100000, output_eff_R = FALSE)
time_df$time[4000+i] <- r$sum_time
r <- simbac_ARG(100, 5, 100, delta = 5, node_max = 100000, output_eff_R = FALSE, optimise_site = TRUE)
time_df$time[5000+i] <- r$sum_time
if (i%%100 == 0) {print(paste("Complete", i, "iterations"))}
}
library(ggplot2)
library(dplyr) # For sample data creation
# 1. Create Sample Data
set.seed(123)
df <- data.frame(
Group = rep(c("A", "B", "C", "D"), each = 50),
Value = c(rnorm(50, 10, 2), rnorm(50, 12, 1.5), rnorm(50, 8, 3), rnorm(50, 15, 2.5))
)
# 2. Create a basic violin plot
p <- ggplot(df, aes(x = Group, y = Value, fill = Group)) +
geom_violin(trim = FALSE) + # trim=FALSE extends violins to min/max data points
geom_boxplot(width = 0.1, fill = "white", alpha = 0.7) + # Add boxplots inside
labs(
title = "Violin Plot (X-axis labels visible)",
x = "Group Categories", # X-axis title is still visible
y = "Measured Value"
) +
theme_minimal()
print(p)
# 3. Hide X-axis numbers/strings (tick labels)
p_hidden_x_labels <- p +
labs(title = "Violin Plot (X-axis labels hidden)") +
theme(axis.text.x = element_blank()) # This is the key line
print(p_hidden_x_labels)
# 4. Hide X-axis numbers/strings AND the X-axis title
p_hidden_x_all <- p +
labs(title = "Violin Plot (X-axis labels and title hidden)") +
theme(
axis.text.x = element_blank(),  # Hides the tick labels (numbers/strings)
axis.title.x = element_blank()  # Hides the axis title ("Group Categories")
)
print(p_hidden_x_all)
# 5. Hide X-axis numbers/strings, the X-axis title, AND the tick marks
p_hidden_x_all_and_ticks <- p +
labs(title = "Violin Plot (X-axis completely hidden)") +
theme(
axis.text.x = element_blank(),  # Hides the tick labels
axis.title.x = element_blank(), # Hides the axis title
axis.ticks.x = element_blank()  # Hides the small lines at each tick mark
)
print(p_hidden_x_all_and_ticks)
#| echo: true
ggplot(time_df, aes(x=func, y=time, fill=func)) +
geom_violin(width=1, alpha=0.5) +
geom_boxplot(width=0.1, color="black", alpha=0.2) +
labs(title = "# of leaf lineages = 100, rho = 5",
x = "Functions",
y = "ARG height") +
theme_minimal() +
theme(
plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
axis.title.x = element_text(size = 16),
axis.text.x = element_blank(),
axis.title.y = element_text(size = 16),
axis.text.y = element_text(size = 12),
legend.title = element_text(size = 16),
legend.text = element_text(size = 12)
)
